## 2022-11-07

1. Vue 에서의 데이터 호출 시점
 - 뷰 라이프 사이클 훅을 이용하여 created 에서 데이터를 호출
 - 라우터 네비게이션 가드를 사용해서 데이터를 호출할 수 있음.

라우터 네비게이션 가드 사용시에는 페이지 URL 로 접근 전에 어떠한 행위를 하는 것으로, 화면이 깔끔하게 나올 수 있지만, 사용자 UX 를 고려해서 로딩바, 스피너를 넣어줘야함. <br/>
created 사용시에는 화면에 빨리 뜨지만, 깔끔하지 않을 수도 있음.

```js
// 전역가드
router.beforeEach((to, from, next) => {
	// to: 이동할 url
	// from: 현재 url
	// next: to 에서 지정한 url 로 이동하기 위해 꼭 호출해야 하는 함수

	if (to.matched.some(function(routeInfo) {
    return routeInfo.meta.authRequired;
  })) {
    // 이동할 페이지에 인증 정보가 필요하면 경고 창을 띄우고 페이지 전환은 하지 않음
    alert('Login Please!');
  } else {
    console.log("routing success : '" + to.path + "'");
    next(); // 페이지 전환
  };
});

// 라우터 가드
var router = new VueRouter({
  routes: [
    {
      path: '/login',
      component: Login,
      beforeEnter: function(to, from, next) {
        // 인증 값 검증 로직 추가
      }
    }
  ]
})
```

## 2022-11-06

1. 뷰에서 하이오더 컴포넌트.
 - 컴포넌트의 로직을 재사용하기 위한 기술.
 - 예를 들어, 리스트 컴포넌트에서 각각 데이터를 뿌리는 방법이 같음. 라우터 이름으로 구분하여 각각 데이터를 뿌려주는 하이오더 컴포넌트를 만듬.

```js
// 기존 컴포넌트 대신 공통 처리하는 js
import ListView from '@/views/ListView';
// 이벤트 버스로 각 컴포넌트끼리 이벤트를 공유하도록 함.
import bus from '@/utils/bus.js';

export default function createListView(name) {
  return {
    // 재사용할 컴포넌트의 옵션들
    name: name,
    created() {
      bus.$emit('start:spinner');
      setTimeout(() => {
        this.$store.dispatch('FETCH_LIST', this.$route.name)
          .then(() => {
            console.log('fetched')
            bus.$emit('end:spinner');

          })
          .catch(err => {
            console.log(err);
          });
      }, 3000);
    },
    render(createElement) {
      return createElement(ListView);
    }
  }
}
```

2. 이벤트 버스
 - 예를 들어, 스피너 컴포넌트가 있다. 해당 스피너 컴포넌트에서 emit 을 이용하여 상위로 이벤트를 날릴 수도 있지만, 이벤트 버스를 이용해 이벤트를 전달할 수 있음.

```js
// bus.js
// 이벤트 버스는 src/utils/bus.js
// 이벤트 버스란 빈 이벤트 객체를 통해서 컴포넌트간의 데이터를 주고 받는 것.
import Vue from 'vue';

// bus.js
export default new Vue();

// App.vue
// 이벤트 on/off
created() {
  bus.$on('start:spinner', this.startSpinner);
  bus.$on('end:spinner', this.endSpinner);
},
beforeDestroy() {
  bus.$off('start:spinner', this.startSpinner);
  bus.$off('end:spinner', this.endSpinner);
}

// Sub.vue
// 아래와 같이 액션을 실행하기 전 후로 이벤트를 발생시켜줍니다.
created() {
  bus.$emit('start:spinner');
	created() {
    bus.$emit('start:spinner');
    this.$store.dispatch('FETCH_JOB')
      .then(() => {
        console.log('fetched')
        bus.$emit('end:spinner');

      })
      .catch(err => {
        console.log(err);
      });
  }
  bus.$emit('end:spinner');
}
```

## 2022-11-04

1. 2가지 데이터 흐름 처리
 - vuex 를 이용한 흐름처리로 actions 에 처리한 데이터는 state 로 존재하기 때문에 props 를 사용하지 않고 getters 를 이용하여 처리할 수 있음.
 - 공통 컴포넌트에 대해 각 views 에 props 를 전달하여 처리할 수 있음.
2. slot 을 이용하여 간단하게 컴포넌트를 공통화 처리 밑 교통정리 가능.
 - 기존에는 내부에서 v-if 를 사용해서 처리했는데 그러다보니 코드량이나 if 문이 너무 많아지는 것을 확인함.
 - slot 을 이용하여 교통정리가 가능하고 각 뷰에서 필요한 데이터를 받아서 나타낼 수 있음.

**예시**
 ```html
 // views
<div>
  <user-profile :info="fetchedUser">
    <div slot="username">{{ fetchedUser.id }}</div>
    <span slot="time">{{ 'Joined ' + fetchedUser.created }}, </span>
    <span slot="karma">{{ fetchedUser.karma }}</span>
  </user-profile>
</div>

// components
<div class="user-container">
  <div>
    <i class="fas fa-user"></i>
  </div>
  <div class="user-description">
    <slot name="username">
      <!-- 상위 컴포넌트에서 정의할 영역 -->
    </slot>
    <div class="time">
      <slot name="time"></slot>
      <slot name="karma"></slot>
    </div>
  </div>
</div>
 ```

## 2022-11-03

1. v-html, v-text 은 innerHTML 과 innerText 와 같음.
v-html 의 경우, innerHTML 과 마찬가지로 xss 에 취약하기 때문에 주의해서 사용.

2. vue 트랜지션 사용하여 여러 애니메이션을 추가해줄 수 있음. <br/>
아래는 라우터 트랜지션으로 특정 링크로 이동시 부드러운 화면 전환을 추가함.

```html
<transition name="page">
  <router-view></router-view>
</transition>

<style>
/* Router Transition */
.page-enter-active, .page-leave-active {
  transition: opacity .5s;
}
.page-enter, .page-leave-to {
  opacity: 0;
}
</style>
```

## 2022-11-02

1. 한글이나 중국어같이 영어가 아닌 글자들은 한 글자가 영어보다 많은 정보를 담고있기 때문에 키입력 순간부터 입력완료 까지 시간이 걸리고, 이는 `keydown` 이벤트가 이미 발생되고 난 후에도 진행중일 수 있다는 것을 의미하고 그 상태를 `isComposing` 이란 event 객체 속성값으로 확인 할 수 있다는 것이다. `isComposing` 이 `true` 인 경우, 아직 글자가 구성되고 있다는 의미라고 한다. <br/>
대부분 `keydown` 에서 `isCompsing` 이 `true` 일 때, `return` 을 쳐서 해결한다고함. <br/>
근데 생각처럼 해결이 잘 되지는 않음...

## 2022-11-01

1. vue 아래와 같은 폴더 구성으로 만듬. 구체적으로 더 상세해질 수 있음.
```
project
    public
    src
        assets
        components - 컴포넌트
        router - 라우터 설정
        views - 라우터에 들어가는 뷰컴포넌트
        api
        store
```

2. vuex 에서 actions, mutations 사용
- 모든 api 는 actions 에서 사용함. 그런 뒤, mutations 를 이용하여 state 를 커밋해줌.
- actions 는 dispatch, mutations 는 commit 임.
- getters 를 만들어 state 를 리턴해주는데, mapGetter 를 사용하면 좀 더 깔끔하게 가능함. (참고)

```js
import Vue from 'vue';
import Vuex from 'vuex';
import mutations from './mutations';
import actions from './actions';

Vue.use(Vuex);

export const store = new Vuex.Store({
  state: {
    news: [],
    ask: [],
    jobs: []
  },
  getters: {
    fetchedAsk(state) {
      return state.ask;
    }
  },
  mutations,
  actions
});

```